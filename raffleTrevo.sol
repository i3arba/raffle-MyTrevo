// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./vrf.sol";
import "./payerPolygon.sol";
import {ReceiverPolygon} from "./receiverPolygon.sol";

/// @title Raffle 
/// @author Bozz & Barba
/// @notice This contract is used to create NFTs and Token raffles.
/// @dev This contract basically divides into Creator, Raffles, CCIP, Tickets, Lists, Helpers, and Administrative Functions.

/*                                                                      
    :----:                                                                  
  --.:  ..--     .:-..    .:..:     .....    ..   :     ::::.               
  =*:      .*=      -      :. .-     .....     :. -     -.   =               
  --..  ::--       -      :.  -     -:...      :-      .-:.::               
    :----:                                                                  
      ..                                                      
*/

contract RaffleMyTrevo is Ownable {

  /// STRUCTS

  /// @dev The struct of a Raffle
  struct Raffle{
    uint256 id;
    address addressPrize;
    uint256 idPrize;
    string chainPrize;
    uint256 softcap;
    uint256 duration;
    uint256 deadLine;
    uint256 totalPlayers;
    uint256 totalSold;
    uint256 salesGoal;
    uint256 requestId;
    uint256 randomNumberVRF;
    uint256 getTimeVRF;
    address winner;
    RaffleStatus status;
    address creator;
    uint256 nextTicketId;
    bool checkedCollection;
    TokenType prizeTokenType;
    uint256 amount;
  }

  /// @dev The struct of a Creator
  struct Creator{
    uint256 id;
    address wallet;
    uint256 totalRaffles;
    uint256 paids;
    uint256 canceleds;
    uint256 reputation;
    bool authorized;
  }

  /// @dev The struct of a Ticket
  struct Ticket{
    address user;
    uint256 number;
    address stableCoin;
    bool refunded;
    bool winner;
  }

  /// @dev The struct of a Stable Coin
  struct StableCoin{
    uint256 decimals;
    bool valid;
  }

  /// ENUMS
  
  /// @dev Enums for the status of a raffle
  enum RaffleStatus{
    Closed,
    Open,
    Canceled,
    Paid,
    Drawn
  }

  /// @dev Enums for the type of a prize
  enum TokenType {
    ERC20,
    ERC721,
    ERC1155
  }

  /// MMODIFIERS

  /// @dev Modifier to grant access to create raffles only to creators permitted by Trevo
  modifier onlyCreator() {
    require(creators[msg.sender].authorized == true, "Only creators are allowed");
     require(creators[msg.sender].reputation >= 1, "Creator's reputation must be equal to or greater than 1");
    _;
  }

  /// EVENTS

  /// @dev Event triggered when a new stablecoin is added to the contract
  event newStableCoin(address indexed _stableCoin);

  /// @dev Event triggered when a stablecoin is removed from the contract
  event removeStableCoin(address indexed _stableCoin);

  /// @dev Event triggered when a new raffle is created in the contract
  event openRaffle(uint256 indexed _id, address indexed _addressPrize, uint256 indexed _idPrize, string _chainPrize, uint256 _duration, address _creator, uint256 _amount);

  /// @dev Event triggered when a raffle is canceled
  event canceledRaffle(uint256 indexed _id, address _creator);

  /// @dev Event triggered when a new creator is added to the contract
  event addCreator(address indexed _creator);

  /// @dev Event triggered when a creator is removed from the contract
  event removedCreator(address indexed _creator);

  /// @dev Event triggered when a raffle is verified by Trevo on OpenSea
  event checkCollection(uint256 indexed _raffleId, bool indexed _check);

  /// @dev Event triggered when a winner has their prize paid by the creator
  event paidWinner(uint256 indexed _raffleId, address indexed _winner, address _addressPrize, uint256 _idPrize, string indexed _chainPrize, uint256 _amount);

  /// @dev Event triggered when a creator receives the tickets after a raffle prize has been paid to the winner
  event creatorPaid(address indexed _creator, uint256 indexed _raffleId, uint256 indexed total);

  /// @dev Event triggered when Trevo withdraws the fee from the raffles
  event withdrawOwner(address indexed _stableCoin, uint256 indexed total);

  /// @dev Event triggered when a ticket is purchased by a user
  event ticketSold(address indexed _buyer, uint256 indexed _raffleId, uint256 numberOfTickets, address _stableCoin);

  /// @dev Event triggered when a random number is requested from Chainlink
  event VRFcalled(uint256 indexed _requestId);

  /// @dev Event triggered when the random number generated by Chainlink is obtained
  event answerVRF(bool fulfilled, uint256[] randomWords, uint256 randomValue);

  /// @dev Event triggered when a user withdraws their refund from a canceled raffle
  event withdrawRefund(address indexed _user, uint256 indexed _raffleId, uint256 numberOfTickets, address _stableCoin);

  /// @dev Event triggered when a raffle is sent to Ethereum by the CCIP and we await a response
  event waitPayerEtherum(uint256 indexed _raffleId, address indexed _winner, address _addressPrize, uint256 _idPrize, string indexed _chainPrize, uint256 _amount);

  /// MAPPINGS

  /// @dev Mapping of raffles by raffle ID
  mapping(uint256 => Raffle) public raffles;

  /// @dev Mapping of creators by creator address
  mapping(address => Creator) public creators;

  /// @dev Mapping of stablecoins by stablecoin address
  mapping(address => StableCoin) public validStableCoins;

  /// @dev Mapping of raffle tickets by raffle ID and ticket number
  mapping(uint256 => mapping(uint256 => Ticket)) public tickets;

  /// @dev Mapping of ticket sales for each stablecoin for a raffle by raffle ID and stablecoin address
  mapping(uint256 => mapping(address => uint256)) public raffleStableCoinSales;

  /// @dev Mapping of accumulated fees for each stablecoin by stablecoin address
  mapping(address => uint256) public accumulatedFees;

  /// @dev Mapping of the total refund for a user for each stablecoin of a raffle by raffle ID, user's wallet address, and stablecoin address
  mapping(uint256 => mapping(address => mapping(address => uint256))) public totalToRefund;

  /// @dev Mapping of all tickets purchased by a user from a raffle by user's wallet address and raffle ID
  mapping(address => mapping(uint256 => uint256[])) public userTickets;

  /// @dev Mapping for converting a number into a prize type
  mapping(TokenType => uint256) public tokenTypeToUint;

  /// ARRAYS
  
  /// @dev Array with the addresses of stablecoins added to the contract
  address[] public validStableCoinsArray;

  /// GLOBAL VARIABLES

  /// @dev Next raffle ID
  uint256 public nextRaffleId = 1;

  /// @dev Next creator ID
  uint256 public nextCreatorId = 1;

  /// @dev Total raffles
  uint256 public totalRaffles = 0;

  /// @dev Raffle fee
  uint256 public feeRaffle = 3;

  /// @dev Wallet address for receiving fees
  address public walletFees;

  /// IMPORTED CONTRACTS

  /// @dev Chainlink VRF contract
  VRFChainLink vrfChainLink = VRFChainLink(0xFE063094D132E202f321Dd55dD382522D984B8d5);

  /// @dev Contract to transfer the prizes to the winners on Polygon
  PayerPolygon payerPolygon = PayerPolygon(0x3ECDef595adDE6b71748481D00D43794D0c3b7D0);

  /// @dev Contract that sends the information of a raffle to Ethereum (CCIP)
  ReceiverPolygon ccip = ReceiverPolygon(payable(0x5b17E8c24E253954832644bd363b8b974c71f363));
  
  /// CONSTRUCTOR

  /// @notice Constructor of the contract that assigns a number to each type of prize for the raffles
  constructor() payable{
    tokenTypeToUint[TokenType.ERC20] = 0;
    tokenTypeToUint[TokenType.ERC721] = 1;
    tokenTypeToUint[TokenType.ERC1155] = 2;
  }

  /// FUNCTIONS

  /// @dev Receive 
  receive() external payable{}

  /// @dev Function for the contract owner to add new creators
  /// @param _creator Creator's wallet address
  function setCreator(address _creator) public onlyOwner {
    require(_creator != address(0), "Invalid wallet address");
    require(creators[_creator].wallet == address(0), "Creator already exists");

    Creator memory newCreator = Creator({
      id: nextCreatorId,
      wallet: _creator,
      totalRaffles: 0,
      paids: 0,
      canceleds: 0,
      reputation: 5,
      authorized: true
    });

    creators[_creator] = newCreator;
    nextCreatorId++;

    emit addCreator(_creator);
  }

  /// @dev Function for the contract owner to remove a creator
  /// @param _creator Creator's wallet address
  function removeCreator(address _creator) public onlyOwner {
    require(_creator != address(0), "Invalid wallet address");
    creators[_creator].authorized == false;

    emit removedCreator(_creator);
  }

  /// @dev Function for the contract owner to add a new stablecoin
  /// @param _stableCoin Stablecoin address
  /// @param _decimals Decimals of the stablecoin
  function addStable(address _stableCoin, uint256 _decimals) public onlyOwner {
    require(!validStableCoins[_stableCoin].valid, "Address already added");

    validStableCoins[_stableCoin] = StableCoin({
      decimals: _decimals,
      valid: true
    });

    validStableCoinsArray.push(_stableCoin);
    emit newStableCoin(_stableCoin);
  }

  /// @dev Function for the contract owner to remove a stablecoin from the contract
  /// @param _stableCoin Stablecoin address
  function removeStable(address _stableCoin) public onlyOwner {
    require(validStableCoins[_stableCoin].valid, "Address not found");

    validStableCoins[_stableCoin].valid = false;

    for (uint256 i = 0; i < validStableCoinsArray.length; i++) {
      if (validStableCoinsArray[i] == _stableCoin) {
        validStableCoinsArray[i] = validStableCoinsArray[validStableCoinsArray.length - 1];
        validStableCoinsArray.pop();
        break;
      }
    }

    emit removeStableCoin(_stableCoin);
  }

  /// @dev Function to check if the chain in the raffle is part of the valid chains in the contract
  /// @param _chain "Ethereum" || "Polygon"
  function isValidChain(string memory _chain) internal pure returns (bool) {
    return (
      keccak256(bytes(_chain)) == keccak256(bytes("Ethereum")) ||
      keccak256(bytes(_chain)) == keccak256(bytes("Polygon"))
    );
  }

  /// @dev Function to check if the duration in the raffle is within the allowed durations in the contract
  /// @param _duration Duration in seconds: 604800 || 1209600 || 1814400 || 2592000
  function isValidDuration(uint256 _duration) internal pure returns (bool) {
    uint256[] memory allowedDurations = new uint256[](4);
    allowedDurations[0] = 7 days;
    allowedDurations[1] = 14 days;
    allowedDurations[2] = 21 days;
    allowedDurations[3] = 30 days;

    for (uint256 i = 0; i < allowedDurations.length; i++) {
      if (_duration == allowedDurations[i]) {
        return true;
      }
    }
    return false;
  }

  /// @dev Function to check if the softcap in the raffle is greater than or equal to 1% and less than or equal to 100%
  /// @param _softcap softcap number
  function isValidSoftcap(uint256 _softcap) internal pure returns (bool) {
    return (_softcap >= 1 && _softcap <= 100);
  }

  /// @dev Function for Creators to open new raffles.
  /// @param _addressPrize Prize address
  /// @param _idPrize NFT Token ID. If it's ERC20, specify 1
  /// @param _salesGoal Number of tickets that can be sold
  /// @param _amount If the prize is an NFT, specify 1; if it's ERC20, provide the token amount with decimals included
  /// @param _chainPrize Ethereum || Polygon
  /// @param _softcap Minimum acceptable ticket sales quantity for the raffle
  /// @param _duration Maximum duration for the raffle
  /// @param _prizeTokenType 0 = ERC20 || 1 = ERC721 || 2 = ERC1155
  function setRaffle(address _addressPrize, uint256 _idPrize, uint256 _salesGoal, uint256 _amount, string memory _chainPrize, uint256 _softcap, uint256 _duration, TokenType _prizeTokenType) public payable onlyCreator returns(uint256 _raffleId){
    require(isValidChain(_chainPrize), "Invalid chain");
    require(_addressPrize != address(0), "Invalid prize address");
    require(isValidDuration(_duration), "Invalid duration");
    require(isValidSoftcap(_softcap), "Invalid softcap percentage");
    require(_amount > 0, "Amount must be greater than 0");

    uint256 fee = 2000000000000000000 + (_salesGoal * 1000000000000000);
    require(msg.value >= fee, "Insufficient balance to create raffle");

    uint256 raffleId = nextRaffleId;

    Raffle memory newRaffle = Raffle({
      id: raffleId,
      addressPrize: _addressPrize,
      idPrize: _idPrize,
      chainPrize: _chainPrize,
      softcap: _softcap,
      duration: _duration,
      deadLine: block.timestamp + _duration,
      totalPlayers: 0,
      totalSold: 0,
      salesGoal: _salesGoal, 
      requestId: 0,
      randomNumberVRF: 0,
      winner: address(0),
      status: RaffleStatus.Open,
      creator: msg.sender,
      nextTicketId: 1,
      checkedCollection: false,
      prizeTokenType: _prizeTokenType,
      amount: _amount,
      getTimeVRF: 0
    });

    raffles[raffleId] = newRaffle;
    nextRaffleId++;
    totalRaffles++;
    creators[msg.sender].totalRaffles++;

    emit openRaffle(raffleId, _addressPrize, _idPrize, _chainPrize, _duration, msg.sender, _amount);

    return raffleId;
  }
  
  /// @dev Function for the contract owner to specify whether the raffle has a verified contract on OpenSea or not.
  /// @param _raffleId Raffle ID
  /// @param _check true = verified || false = unverified
  function setChecked(uint256 _raffleId, bool _check) public onlyOwner{
    raffles[_raffleId].checkedCollection = _check;
    emit checkCollection(_raffleId, _check);
  }

  /// @dev Function to execute the raffle.
  /// @param _raffleId Raffle ID
  function raffle(uint256 _raffleId) public {
    require(raffles[_raffleId].id != 0, "Raffle does not exist");
    require(raffles[_raffleId].status == RaffleStatus.Open, "Raffle is not open");

    if(raffles[_raffleId].totalPlayers == raffles[_raffleId].salesGoal){
      callVRF(_raffleId);
      return;
    }

    uint256 softcap = (raffles[_raffleId].salesGoal * raffles[_raffleId].softcap) / 100;
    
    if (block.timestamp >= raffles[_raffleId].deadLine && raffles[_raffleId].totalPlayers >= softcap){
      callVRF(_raffleId);
    }else {
      raffles[_raffleId].status = RaffleStatus.Canceled;
      creators[raffles[_raffleId].creator].canceleds++;
      
      emit canceledRaffle(_raffleId, raffles[_raffleId].creator);
    }
  }
  
  /// @dev Internal function to request a random number from Chainlink.
  /// @param _raffleId Raffle ID
  function callVRF(uint256 _raffleId) internal returns(uint256 _requestId){
    raffles[_raffleId].status = RaffleStatus.Closed;

    uint256 numbersRaffle = raffles[_raffleId].totalPlayers;
    uint256 requestId = vrfChainLink.requestRandomWords(numbersRaffle);
    raffles[_raffleId].requestId = requestId;
    raffles[_raffleId].getTimeVRF = block.timestamp;

    emit VRFcalled(requestId);
    return requestId;
  }
  
  /// @dev Function to check if a random number was obtained from Chainlink and pass the winner to the prize transfer contracts.
  /// @param _raffleId Raffle ID
  function receiveVRF(uint256 _raffleId) public {
    require(raffles[_raffleId].status == RaffleStatus.Closed, "This raffle number has not been drawn yet");

    (bool fulfilled, uint256[] memory randomWords, uint256 randomValue) = vrfChainLink.getRequestStatus(raffles[_raffleId].requestId);
    require(fulfilled, "VRF request not fulfilled");
    raffles[_raffleId].status = RaffleStatus.Drawn;

    emit answerVRF(fulfilled, randomWords, randomValue);

    raffles[_raffleId].randomNumberVRF = randomValue;
    address winner = tickets[_raffleId][randomValue].user;
    raffles[_raffleId].winner = winner;
    tickets[_raffleId][randomValue].winner = true;

    TokenType prizeTokenType = raffles[_raffleId].prizeTokenType;
    uint256 prizeTokenTypeUint = tokenTypeToUint[prizeTokenType];

    if(keccak256(bytes(raffles[_raffleId].chainPrize)) == keccak256(bytes("Ethereum"))){

      bytes memory data = abi.encode(
        raffles[_raffleId].creator,
        raffles[_raffleId].winner,
        raffles[_raffleId].randomNumberVRF,
        raffles[_raffleId].id,
        raffles[_raffleId].addressPrize,
        raffles[_raffleId].idPrize,
        prizeTokenTypeUint,
        raffles[_raffleId].amount,
        totalRaffles
      );

      ccip.send(16015286601757825753, 0x990790aD365ef370d6f8526759f234456D4A05d1, data); //16015286601757825753 Sepolia // 0x990790aD365ef370d6f8526759f234456D4A05d1 payerEthereum
      
      emit waitPayerEtherum(_raffleId, raffles[_raffleId].winner, raffles[_raffleId].addressPrize, raffles[_raffleId].idPrize, raffles[_raffleId].chainPrize, raffles[_raffleId].amount);
    } else{

      bool paymentSuccess = payerPolygon.payWinner(
        raffles[_raffleId].creator,
        raffles[_raffleId].winner,
        raffles[_raffleId].randomNumberVRF,
        raffles[_raffleId].id,
        raffles[_raffleId].addressPrize,
        raffles[_raffleId].idPrize,
        prizeTokenTypeUint,
        raffles[_raffleId].amount
        );

      if (paymentSuccess) {
        
        raffles[_raffleId].status = RaffleStatus.Paid;
        creators[raffles[_raffleId].creator].paids++;
        creators[raffles[_raffleId].creator].reputation += 1;
        payCreator(_raffleId);

        emit paidWinner(_raffleId, raffles[_raffleId].winner, raffles[_raffleId].addressPrize, raffles[_raffleId].idPrize, raffles[_raffleId].chainPrize, raffles[_raffleId].amount);
      } else {

        raffles[_raffleId].status = RaffleStatus.Canceled;
        creators[raffles[_raffleId].creator].canceleds++;

        if (creators[raffles[_raffleId].creator].reputation > 0) {
          creators[raffles[_raffleId].creator].reputation -= 1;
        }

        emit canceledRaffle(_raffleId, raffles[_raffleId].creator);
      }  
    }
  }

  /// @dev Function for the contract owner to cancel a raffle if it has been in a closed state for more than 1 day
  /// @param _raffleId Raffle ID
  function forceRaffle(uint256 _raffleId) public onlyOwner() {
    require(raffles[_raffleId].status == RaffleStatus.Closed, "This raffle number has not been drawn yet"); 

    if(raffles[_raffleId].getTimeVRF != 0 && block.timestamp >= (raffles[_raffleId].getTimeVRF + 86400)){

       raffles[_raffleId].status = RaffleStatus.Canceled;
      creators[raffles[_raffleId].creator].canceleds++;

      if (creators[raffles[_raffleId].creator].reputation > 0) {
        creators[raffles[_raffleId].creator].reputation -= 1;
      }

      emit canceledRaffle(_raffleId, raffles[_raffleId].creator);
    }   
  }

  /// @dev Function for the contract owner to inform whether the prize transfer contract on Ethereum has paid the winner or not.
  /// @param _raffleId Raffle ID
  /// @param _paid true = paid || false = canceled
  function receiveEthereum(uint256 _raffleId, bool _paid) public onlyOwner() {
    require(raffles[_raffleId].status == RaffleStatus.Drawn, "VRF request not fulfilled");

    if(_paid == true){
      
      raffles[_raffleId].status = RaffleStatus.Paid;
      creators[raffles[_raffleId].creator].paids++;
      creators[raffles[_raffleId].creator].reputation += 1;
      payCreator(_raffleId);

      emit paidWinner(_raffleId, raffles[_raffleId].winner, raffles[_raffleId].addressPrize, raffles[_raffleId].idPrize, raffles[_raffleId].chainPrize, raffles[_raffleId].amount);
    }else{

      raffles[_raffleId].status = RaffleStatus.Canceled;
      creators[raffles[_raffleId].creator].canceleds++;

      if (creators[raffles[_raffleId].creator].reputation > 0) {
        creators[raffles[_raffleId].creator].reputation -= 1;
      }

      emit canceledRaffle(_raffleId, raffles[_raffleId].creator);
    }
  }

  /// @dev Internal function that is executed to pay the tickets of a raffle to the creator of that raffle if the prize is transferred to the winner.
  /// @param _raffleId Raffle ID
  function payCreator(uint256 _raffleId) internal {
    address[] memory stableCoins = getValidStableCoins();
    uint256 totalPaidToCreator = 0;

    for (uint256 i = 0; i < stableCoins.length; i++) {
      address stableCoinAddress = stableCoins[i];
      uint256 soldForStableCoin = getSoldForStableCoin(_raffleId, stableCoinAddress);

      uint256 feeAmount = ((soldForStableCoin * 10 ** validStableCoins[stableCoinAddress].decimals) * feeRaffle) / 100;
      uint256 netAmount = ((soldForStableCoin * 10 ** validStableCoins[stableCoinAddress].decimals) - feeAmount);

      IERC20 stableCoinToken = IERC20(stableCoinAddress);
      uint256 contractBalance = stableCoinToken.balanceOf(address(this));
      require(contractBalance >= netAmount, "Insufficient contract balance");
      require(stableCoinToken.transfer(raffles[_raffleId].creator, netAmount), "Transfer failed");

      totalPaidToCreator += netAmount;
      updateAccumulatedFee(stableCoinAddress, feeAmount);
    }

    emit creatorPaid(raffles[_raffleId].creator, _raffleId, totalPaidToCreator);
  }

  /// @dev Function to obtain a list of all raffles with an open status.
  /// @return openRaffles All raffles with an open status.
  function getOpenRaffles() public view returns (Raffle[] memory) {
    uint256 count = 0;

    for (uint256 i = 1; i <= totalRaffles; i++) {
      if (raffles[i].status == RaffleStatus.Open) {
        count++;
      }
    }

    Raffle[] memory openRaffles = new Raffle[](count);
    uint256 index = 0;

    for (uint256 i = 1; i <= totalRaffles; i++) {
      if (raffles[i].status == RaffleStatus.Open) {
        openRaffles[index] = raffles[i];
        index++;
      }
    }

    return openRaffles;
  }

  /// @dev Function to obtain a list of all raffles with an closed status.
  /// @return closedRaffles All raffles with an closed status.
  function getClosedRaffles() public view returns (Raffle[] memory) {
    uint256 count = 0;

    for (uint256 i = 1; i <= totalRaffles; i++) {
      if (raffles[i].status == RaffleStatus.Closed) {
        count++;
      }
    }

    Raffle[] memory closedRaffles = new Raffle[](count);
    uint256 index = 0;

    for (uint256 i = 1; i <= totalRaffles; i++) {
      if (raffles[i].status == RaffleStatus.Closed) {
        closedRaffles[index] = raffles[i];
        index++;
      }
    }

    return closedRaffles;
  }

  /// @dev Function to obtain a list of all raffles created by a creator
  /// @param _creator Creator's wallet address
  /// @return rafflesByCreator All raffles by a creator
  function getRafflesByCreator(address _creator) public view returns (Raffle[] memory) {
    uint256 count = 0;

    for (uint256 i = 1; i <= totalRaffles; i++) {
      if (raffles[i].creator == _creator) {
        count++;
      }
    }

    Raffle[] memory rafflesByCreator = new Raffle[](count);
    uint256 index = 0;

    for (uint256 i = 1; i <= totalRaffles; i++) {
      if (raffles[i].creator == _creator) {
        rafflesByCreator[index] = raffles[i];
        index++;
      }
    }

    return rafflesByCreator;
  }

  /// @dev Function to obtain a list of the last 4 winners of raffles
  /// @return recentPaidRaffles Last 4 winners
  function getRecentPaidRaffles() public view returns (Raffle[] memory) {
    uint256 count = 0;
    for (uint256 i = 1; i <= totalRaffles; i++) {
      if (raffles[i].status == RaffleStatus.Paid) {
        count++;
      }
    }

    uint256 maxRafflesToShow = 4;
    if (count < maxRafflesToShow) {
        maxRafflesToShow = count;
    }

    Raffle[] memory recentPaidRaffles = new Raffle[](maxRafflesToShow);
    uint256 index = 0;

    for (uint256 i = totalRaffles; i >= 1 && index < maxRafflesToShow; i--) {
      if (raffles[i].status == RaffleStatus.Paid) {
        recentPaidRaffles[index] = raffles[i];
        index++;
      }
    }

    return recentPaidRaffles;
  }

  /// @dev Function to obtain a list of all raffles for which a user has purchased tickets.
  /// @return userRaffles Raffles a user has purshased tickets
  function getRafflesByUser(address _user) public view returns (Raffle[] memory) {
    uint256 count = 0;

    for (uint256 i = 1; i <= totalRaffles; i++) {
      for (uint256 j = 1; j < raffles[i].nextTicketId; j++) {
        if (tickets[i][j].user == _user) {
          count++;
          break;
        }
      }
    }

    Raffle[] memory userRaffles = new Raffle[](count);
    uint256 index = 0;

    for (uint256 i = 1; i <= totalRaffles; i++) {
      for (uint256 j = 1; j < raffles[i].nextTicketId; j++) {
        if (tickets[i][j].user == _user) {
          userRaffles[index] = raffles[i];
          index++;
          break;
        }
      }
    }

    return userRaffles;
  }

  /// @dev Function for a user to purchase tickets for a raffle with their chosen stablecoin
  /// @param _raffleId Raffle ID
  /// @param numberOfTickets Amount of tickets
  /// @param _stableCoin Stablecoin address
  function buyTicket(uint256 _raffleId, uint256 numberOfTickets, address _stableCoin) public {
    require(raffles[_raffleId].id != 0, "Raffle does not exist");
    require(raffles[_raffleId].status == RaffleStatus.Open, "Raffle is not open for ticket purchase");
    require(validStableCoins[_stableCoin].valid, "Invalid stable coin address");
    require(numberOfTickets > 0, "Must set the number of tickets!");
    require(raffles[_raffleId].totalPlayers + numberOfTickets <= raffles[_raffleId].salesGoal, "Maximum sales exceeded");

    IERC20 stableCoin = IERC20(_stableCoin);
    uint256 totalCost = numberOfTickets * 10 ** validStableCoins[_stableCoin].decimals;
    require(stableCoin.balanceOf(msg.sender) >= totalCost, "Insufficient balance");
    require(stableCoin.allowance(msg.sender, address(this)) >= totalCost, "You need to approve the total cost of the tickets");
    require(stableCoin.transferFrom(msg.sender, address(this), totalCost), "Buy Tickets has not been completed");

    for (uint256 i = 0; i < numberOfTickets; i++) {
      uint256 currentTicketId = raffles[_raffleId].nextTicketId;
      tickets[_raffleId][currentTicketId] = Ticket({
          user: msg.sender,
          number: currentTicketId,
          stableCoin: _stableCoin,
          refunded: false,
          winner: false
      });

      userTickets[msg.sender][_raffleId].push(currentTicketId);

      raffles[_raffleId].nextTicketId++;
      raffles[_raffleId].totalPlayers++;
      raffles[_raffleId].totalSold++;
    }

    raffleStableCoinSales[_raffleId][_stableCoin] += numberOfTickets;

    emit ticketSold(msg.sender, _raffleId, numberOfTickets, _stableCoin);

    if(raffles[_raffleId].totalPlayers == raffles[_raffleId].salesGoal) {
      raffle(_raffleId);
    }
  }

  /// @dev Function for the contract owner to purchase tickets for another wallet for a specific reason, e.g. promotions
  /// @param _raffleId Raffle ID
  /// @param numberOfTickets Amount of tickets
  /// @param _to Wallet address that will be the buyer of these tickets
  function buyTicketTo(uint256 _raffleId, uint256 numberOfTickets, address _to) public onlyOwner{
    require(raffles[_raffleId].id != 0, "Raffle does not exist");
    require(raffles[_raffleId].status == RaffleStatus.Open, "Raffle is not open for ticket purchase");
    require(numberOfTickets > 0, "Must set the number of tickets!");
    require(raffles[_raffleId].totalPlayers + numberOfTickets <= raffles[_raffleId].salesGoal, "Maximum sales exceeded");

    for (uint256 i = 0; i < numberOfTickets; i++) {
      uint256 currentTicketId = raffles[_raffleId].nextTicketId;
      tickets[_raffleId][currentTicketId] = Ticket({
          user: _to,
          number: currentTicketId,
          stableCoin: 0x2B7a3E5dF23a6087842375e6B50d96226E9d6F17,
          refunded: true,
          winner: false
      });

      userTickets[msg.sender][_raffleId].push(currentTicketId);

      raffles[_raffleId].nextTicketId++;
      raffles[_raffleId].totalPlayers++;
    }

    emit ticketSold(msg.sender, _raffleId, numberOfTickets, 0x2B7a3E5dF23a6087842375e6B50d96226E9d6F17);

    if(raffles[_raffleId].totalPlayers == raffles[_raffleId].salesGoal) {
      raffle(_raffleId);
    }
  }

  /// @dev Function for a user to request a refund for a canceled raffle.
  /// @param _raffleId Raffle ID
  function refundTicket(uint256 _raffleId) public {
    require(raffles[_raffleId].status == RaffleStatus.Canceled, "The raffle has not been canceled");

    address[] memory stableCoins = getValidStableCoins();

    for (uint256 i = 0; i < stableCoins.length; i++) {
      uint256 totalTickets = raffles[_raffleId].totalSold;

      if (totalTickets > 0) {

        for (uint256 j = 1; j <= totalTickets; j++) {
          Ticket storage ticket = tickets[_raffleId][j];

          if (ticket.user == msg.sender && ticket.refunded == false) {
            ticket.refunded = true;
            totalToRefund[_raffleId][msg.sender][ticket.stableCoin] += 1;
          }
        }
      }
    }

    for (uint256 i = 0; i < stableCoins.length; i++) {
      address stableCoinAddress = stableCoins[i];

      uint256 balanceToken = (totalToRefund[_raffleId][msg.sender][stableCoinAddress] * 10 ** validStableCoins[stableCoinAddress].decimals);

      if (balanceToken > 0) {
        IERC20 stableCoinToken = IERC20(stableCoinAddress);
        require(stableCoinToken.transfer(msg.sender, balanceToken), "Refund failed");

        emit withdrawRefund(msg.sender, _raffleId, totalToRefund[_raffleId][msg.sender][stableCoinAddress] * 10 ** validStableCoins[stableCoinAddress].decimals, stableCoinAddress);
      }
    }
  }
  
  /// @dev Internal function to update the accumulated fee balance for each stablecoin of Trevo.
  /// @param _stableCoin Stablecoin address
  /// @param _amount Fee amount
  function updateAccumulatedFee(address _stableCoin, uint256 _amount) internal {
    accumulatedFees[_stableCoin] += _amount;
  }

  /// @dev Function to get a list of all registered stablecoin addresses in the contract.
  /// @return validStableCoinsArray List of all registered stablecoin addresses
  function getValidStableCoins() public view returns (address[] memory) {
    return validStableCoinsArray;
  } 

  /// @dev Internal function to get the ticket sales quantity in a raffle for each stablecoin.
  /// @param _raffleId Raffle ID
  /// @param _stableCoin Stablecoin address
  /// @return raffleStableCoinSales Ticket sales quantity in a raffle for each stablecoin.
  function getSoldForStableCoin(uint256 _raffleId, address _stableCoin) internal view returns (uint256) {
    return raffleStableCoinSales[_raffleId][_stableCoin];
  }

  /// @dev Function for the contract owner to withdraw the accumulated fees in the contract for each stablecoin.
  function withdrawAccumulatedFees() public onlyOwner {
    address[] memory stableCoins = getValidStableCoins();
    
    for (uint256 i = 0; i < stableCoins.length; i++) {
      address stableCoinAddress = stableCoins[i];

      uint256 balanceStable = accumulatedFees[stableCoinAddress];

      if (balanceStable > 0) {
        IERC20 stableCoinToken = IERC20(stableCoinAddress);
        accumulatedFees[stableCoinAddress] = 0;
        require(stableCoinToken.transfer(walletFees, balanceStable), "Transfer failed");

        emit withdrawOwner(stableCoinAddress, balanceStable);
      }
    }
  }
  
  /// @dev Function for the contract owner to update the fee rate of raffles.
  /// @param _newFee "New fee value, for example: 3 = 3%
  function updateFee(uint256 _newFee) public onlyOwner{
    feeRaffle = _newFee;
  }

  /// @dev Function for the contract owner to update the fee withdrawal address of the contract.
  /// @param _newWallet Withdrawal address
  function updateWalletFees(address _newWallet) public onlyOwner{
    walletFees = _newWallet;
  }

}